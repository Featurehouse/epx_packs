// Test
const generateZipFromUrl = function(url, params, func) {
  // 辅助函数：向zip对象添加一个文件
  function addFileToZip(zip, fileName, data) {
      if (fileName.endsWith('/')) {
          zip.folder(fileName.slice(0, -1));
      } else {
          if (data.fetch) {
              fetch(data.fetch)
              .then(function(response) { return response.blob(); })
              .then(function(blob) { return zip.file(fileName, blob); });
          } else if (data.base64) {
              zip.file(fileName, data.base64, {base64:true});
          } else if (data.raw) {
              zip.file(fileName, data.raw);
          } else {
              zip.file(fileName, '');
          }
      }
  }

  fetch(url).then(function(response){response.json().then(function(jsonData){
    const zip = new JSZip();

    // 处理 static 字段
    const staticFiles = jsonData.static;
    for (const filename in staticFiles) {
      const fileData = staticFiles[filename];
      addFileToZip(zip, filename, fileData);
    }

    // 处理 dynamic 字段
    const dynamicFiles = jsonData.dynamic;
    for (const key in dynamicFiles) {
      const dynamicData = dynamicFiles[key];
      let paramValue = params[key];
      if (isNaN(parseInt(paramValue))) {
        paramValue = dynamicData.default;
      }

      if (paramValue === 'random') {
        const items = dynamicData.items;
        let totalWeight = 0;
        for (const item of items) {
          if (!item.weight) {
            item.weight = 100;
          }
          totalWeight += item.weight;
        }

        let randomNum = Math.floor(Math.random() * totalWeight);
        let selectedItem = null;
        for (const item of items) {
          randomNum -= item.weight;
          if (randomNum < 0) {
            selectedItem = item;
            break;
          }
        }

        if (selectedItem) {
          const files = selectedItem.files;
          for (const filename in files) {
            const fileData = files[filename];
            addFileToZip(zip, filename, fileData);
          }
        }
      } else {
        const itemIndex = parseInt(paramValue);
        const items = dynamicData.items;
        if (items[itemIndex]) {
          const files = items[itemIndex].files;
          for (const filename in files) {
            const fileData = files[filename];
            addFileToZip(zip, filename, fileData);
          }
        }
      }
    }

    zip.generateAsync({type:'blob',compression:'DEFLATE',compressionOptions:{level:5}}).then(func);
  })});
};

(function() {
    const args = (function() {
        const query = window.location.search.substring(1);
        const vars = query.split('&');
        const result = {};
        for (let i = 0; i < vars.length; i++) {
        const pair = vars[i].split('=');
        result[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
        }
        return result;
    })();
    let url = args.zipconfig;
    if (!url) url = '/epx_packs/v2/dl/zipconfig.json';
    generateZipFromUrl(args, url, function(blob) {
        saveAs(blob, 'epx_recommended_pack-' + (function(length) {
            var result = '';
            for (var i = 0; i < length; i++) {
                result += '0123456789abcdef'.charAt(Math.floor(Math.random() * 16));
            }
            return result;
        })(7) + '-v2.zip'));
})();
